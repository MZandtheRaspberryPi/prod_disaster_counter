#include "oled_display.h"
// The blue OLED screen requires a long initialization on power on.
// The code to wait for it to be ready uses 20 bytes of program storage space
// If you are using a white OLED, this can be reclaimed by uncommenting
// the following line (before including Tiny4kOLED.h):
#define TINY4KOLED_QUICK_BEGIN
#include <Tiny4kOLED.h>

namespace oled_display
{

  const static byte x_position = 50;
  const static byte y_position = 0;
  static byte bitmap_counter = 0;
  static int bitmap_counter_direction = 1;
  const static byte size_bitmap_x = 31;
  const static byte size_bitmap_y_num_pages = 4; // 32 pixels
  
  // 'flower_0', 31x32px
  const static unsigned char epd_bitmap_flower_0 [] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xe0, 0xf0, 0x78, 0x38, 
    0x38, 0x78, 0xf0, 0xe0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x3f, 0x7f, 0xf3, 0xe3, 0xc1, 0xc3, 0xc3, 0xff, 0xff, 0xff, 0x7e, 0x3c, 0x3c, 
    0x7c, 0xff, 0xff, 0xff, 0xc7, 0x83, 0x83, 0xc7, 0xff, 0xfe, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x70, 0xfc, 0xfe, 0xcf, 0x87, 0x83, 0x83, 0xc7, 0xff, 0xff, 0xfc, 0x7c, 0x78, 0x78, 0xfc, 
    0xff, 0xff, 0xff, 0x87, 0x87, 0x87, 0x8f, 0xff, 0xfc, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x0f, 0x3f, 0x3c, 0x70, 0x70, 0x78, 0x3c, 0x1f, 
    0x0f, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00
  };
  // 'flower_10', 31x32px
  const static unsigned char epd_bitmap_flower_10 [] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0xe0, 0xe0, 0xe0, 0xc0, 0xc0, 0xc0, 0xe0, 0xf0, 
    0x78, 0x38, 0x38, 0xf8, 0xf0, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x9f, 0xff, 0xfd, 0xf0, 0xe0, 0xe0, 0xf1, 0xff, 0xff, 0x7f, 0x3e, 0x3c, 
    0x78, 0xfc, 0xfc, 0xff, 0xff, 0x0e, 0x0e, 0x0e, 0x8e, 0xfc, 0xfc, 0xf8, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x7e, 0xff, 0xe7, 0xe3, 0xc1, 0xc1, 0xe1, 0xff, 0xff, 0x7f, 0x7e, 0x78, 0x78, 0xf8, 0xf8, 
    0xff, 0xff, 0x1f, 0x0f, 0x0f, 0x1f, 0xff, 0xff, 0xe3, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x1f, 0x3f, 0x78, 0x70, 0x70, 0x38, 0x3f, 0x1f, 0x07, 
    0x07, 0x07, 0x0e, 0x0e, 0x0e, 0x07, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00
  };
  // 'flower_20', 31x32px
  const static unsigned char epd_bitmap_flower_20 [] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xe0, 0xf0, 0x70, 0x70, 0x70, 0xe0, 0xe0, 0xc0, 0xc0, 
    0xe0, 0x70, 0x70, 0x30, 0x70, 0xf0, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x80, 0xc0, 0xc0, 0xef, 0xff, 0xff, 0xf0, 0xf0, 0xf0, 0xf8, 0xff, 0x7f, 0x3f, 0x3f, 
    0x7c, 0xf8, 0xf8, 0xf8, 0xff, 0x3f, 0x1f, 0x1c, 0x38, 0x38, 0xf8, 0xf0, 0xc0, 0x00, 0x00, 0x00, 
    0x1f, 0x3f, 0x3f, 0x71, 0x70, 0xf0, 0xf0, 0xfc, 0xff, 0x7f, 0x7f, 0x7e, 0xf8, 0xf8, 0xf8, 0xf8, 
    0xff, 0x3f, 0x1f, 0x1f, 0x3e, 0xfc, 0xfc, 0xce, 0x0f, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x03, 0x1f, 0x3f, 0x38, 0x70, 0x70, 0x38, 0x3c, 0x1f, 0x0f, 0x07, 0x0f, 
    0x1e, 0x1c, 0x1c, 0x1c, 0x1f, 0x0f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  // 'flower_30', 31x32px
  const static unsigned char epd_bitmap_flower_30 [] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xf0, 0xf0, 0x38, 0x38, 0x38, 0x78, 0xf0, 0xe0, 
    0xc0, 0xc0, 0xe0, 0xe0, 0x70, 0x70, 0xe0, 0xe0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xc0, 0xe0, 0xf0, 0x70, 0x70, 0x3f, 0x3f, 0x7f, 0xf8, 0xf8, 0xf8, 0xf8, 0x7e, 0x3f, 0x3f, 
    0x7f, 0xfc, 0xf8, 0xf0, 0xf0, 0xfc, 0x7f, 0x7f, 0x70, 0xf0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x03, 
    0x0f, 0x0f, 0x1e, 0x1c, 0xf8, 0xf8, 0xfc, 0x3e, 0x3f, 0x3f, 0x3f, 0xfe, 0xf8, 0xf8, 0xf8, 0xf8, 
    0x3e, 0x3f, 0x3f, 0x7f, 0xfc, 0xf8, 0xb8, 0x38, 0x3c, 0x1f, 0x0f, 0x07, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x0f, 0x1f, 0x1f, 0x38, 0x38, 0x38, 0x1c, 0x1e, 0x0f, 0x0f, 0x1f, 0x1e, 0x3c, 
    0x38, 0x38, 0x3c, 0x1f, 0x1f, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  // 'flower_40', 31x32px
  const static unsigned char epd_bitmap_flower_40 [] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xf8, 0x78, 0x3c, 0x1c, 0x38, 0x78, 
    0xf0, 0xe0, 0xc0, 0xc0, 0xc0, 0xe0, 0xe0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xf0, 0xf8, 0xf8, 0x3c, 0x1c, 0x1c, 0x1c, 0x3f, 0xff, 0xfc, 0xf8, 0xf8, 0x7c, 0x3e, 0x3f, 
    0x7f, 0xff, 0xff, 0xf1, 0xe0, 0xe0, 0xf9, 0xff, 0xff, 0xc6, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 
    0x03, 0x07, 0x0f, 0xee, 0xfe, 0xfc, 0x1e, 0x1f, 0x1f, 0x3f, 0xff, 0xfe, 0xf8, 0xf8, 0xf8, 0x78, 
    0x7f, 0x7f, 0xff, 0xff, 0xf1, 0xe0, 0xe0, 0x71, 0x71, 0x7f, 0x3f, 0x1e, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x07, 0x0f, 0x1e, 0x1c, 0x1c, 0x1c, 0x0e, 0x0f, 0x07, 0x0f, 0x3f, 0x3c, 0x78, 0x70, 
    0x70, 0x7c, 0x3f, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };
  // 'flower_50', 31x32px
  const static unsigned char epd_bitmap_flower_50 [] PROGMEM = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xf0, 0xf8, 0x3c, 0x1c, 0x1c, 
    0x3c, 0xf8, 0xf0, 0xe0, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xf8, 0xfc, 0xfe, 0x8e, 0x0e, 0x0e, 0x0e, 0x8e, 0xff, 0xff, 0xff, 0xfc, 0x78, 0x3c, 0x7c, 
    0x7f, 0xff, 0xff, 0xff, 0xe3, 0xc1, 0xc1, 0xe3, 0xff, 0x7f, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xe1, 0xfb, 0xff, 0x3f, 0x0f, 0x0f, 0x0f, 0x1f, 0xff, 0xff, 0xfc, 0xf8, 0xf0, 0x78, 0x78, 
    0xff, 0xff, 0xff, 0xff, 0xc3, 0xc3, 0xc3, 0xc7, 0xef, 0xff, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x01, 0x03, 0x07, 0x0f, 0x0e, 0x0e, 0x07, 0x07, 0x07, 0x0f, 0x3f, 0x7d, 0x70, 0x70, 0x70, 0x78, 
    0x7f, 0x3f, 0x0f, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00
  };
  
  // Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 864)
  const static int epd_bitmap_allArray_LEN = 4;
  const static unsigned char* epd_bitmap_allArray[4] = {
    epd_bitmap_flower_0,
    epd_bitmap_flower_10,
    epd_bitmap_flower_20,
    epd_bitmap_flower_30//,
    //epd_bitmap_flower_40,
    //epd_bitmap_flower_50
  };
  
  // 'moon', 16x16px
  const static unsigned char epd_bitmap_moon [] PROGMEM = {
    0x00, 0x00, 0x00, 0xc0, 0x70, 0x18, 0x0c, 0x7c, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x07, 0x1e, 0x30, 0x20, 0x60, 0x41, 0x43, 0x66, 0x2c, 0x38, 0x18, 0x00, 0x00
  };

  void display_header_row()
  {
    // Position the text cursor
    // In order to keep the library size small, text can only be positioned
    // with the top of the font aligned with one of the four 8 bit high RAM pages.
    // The Y value therefore can only have the value 0, 1, 2, or 3.
    // usage: oled.setCursor(X IN PIXELS, Y IN ROWS OF 8 PIXELS STARTING WITH 0);
    oled.setCursor(0, 0);
    // Write text to oled RAM (which is not currently being displayed).
    oled.print(F("Daily Counter"));
  
  
  }
  void display_counter_row(const unsigned int& days_without_incident)
  {  
    oled.setCursor(0, 2);
    oled.print(F("You're at: "));
    oled.print(days_without_incident);
  }
  void display_info(const unsigned int& days_without_incident, const bool& night_mode)
  {
    // Clear the half of memory not currently being displayed.
    oled.clear();
    display_header_row();
    display_counter_row(days_without_incident);
    if (night_mode)
    {
      oled.bitmap(111, 2, 127, 4, epd_bitmap_moon);
    }
    oled.switchFrame();
  }
  
  void display_congrats()
  {
    // Clear the half of memory not currently being displayed.
    oled.clear();
    oled.setCursor(0, 0);
    // Write text to oled RAM (which is not currently being displayed).
    oled.print(F("Congrats!!!"));
    oled.switchFrame();
  }
  
  void clear_display()
  {
    oled.clear();
    oled.switchFrame();
  }
  
  void cycle_startup_oled_animation()
  {
      oled.bitmap(x_position, y_position, x_position + size_bitmap_x, size_bitmap_y_num_pages, epd_bitmap_allArray[bitmap_counter]);
      // Switch back to being ready to render on the first frame while displaying the second frame.
      oled.switchFrame();
      oled.clear();
      if (bitmap_counter == epd_bitmap_allArray_LEN - 1)
      {
        bitmap_counter_direction = -1;
      }
      else if (bitmap_counter == 0)
      {
        bitmap_counter_direction = 1;
      }
      bitmap_counter += bitmap_counter_direction;
  }

  void setup_display()
  {
    // Send the initialization sequence to the oled. This leaves the display turned off
    oled.begin(0, 0);
    // The default state of the SSD1306 does not turn on the internal charge pump
    oled.enableChargePump();
    oled.setRotation(1);
    // In order to use double buffering on the 128x64 screen,
    // the zoom feature needs to be used, which doubles the height
    // of all pixels.
    oled.enableZoomIn();
    oled.setFont(FONT6X8);
    // Clear the memory before turning on the display
    oled.clear();
    // Switch the half of RAM that we are writing to, to be the half that is non currently displayed
    oled.switchRenderFrame();
    oled.clear();
    oled.bitmap(x_position, y_position, x_position + size_bitmap_x, size_bitmap_y_num_pages, epd_bitmap_allArray[bitmap_counter]);
    // Switch back to being ready to render on the first frame while displaying the second frame.
    oled.switchFrame();
    // Turn on the display
    oled.on();
  }
} // end namespace oled_display
